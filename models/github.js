// Generated by CoffeeScript 1.6.2
(function() {
  'use strict';  module.exports = {
    getRepoFromURL: function(url) {
      var m;

      if (m = url.match(/github\.com\/([^\/]+\/[^\/]+)/)) {
        return m[1];
      }
    },
    loadRepo: function(repo, options) {
      var opts, url;

      if (options == null) {
        options = {};
      }
      opts = $.extend({
        sha: 'HEAD',
        recursive: 1
      }, options, {
        repo: repo
      });
      opts.recursive = opts.recursive ? 1 : 0;
      url = "https://api.github.com/repos/" + opts.repo + "/git/trees/" + opts.sha + "?recursive=" + opts.recursive + "&callback=?";
      return $.ajax($.extend({
        url: url,
        dataType: 'jsonp'
      }, opts));
    },
    parse: function(data) {
      var node, paths, _i, _len, _ref;

      paths = {
        root: {
          name: '',
          path: '',
          children: []
        }
      };
      _ref = data.tree;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        if (node.type === 'blob') {
          this.parseBlob(paths, node);
        } else {
          this.parseTree(paths, node);
        }
      }
      return this.collapse(paths);
    },
    parseBlob: function(paths, node) {
      var name, path, segments;

      segments = ("root/" + node.path).match(/(.*)\/(.*)/);
      node.name = segments[2];
      path = segments[1];
      name = path.substr(5);
      paths[path] || (paths[path] = {
        name: name,
        path: node.path,
        children: []
      });
      return paths[path].children.push(node);
    },
    parseTree: function(paths, node) {
      var name, path;

      path = "root/" + node.path;
      name = path.match(/(.*)\/(.*)/)[2];
      paths[path] || (paths[path] = {
        name: name,
        children: []
      });
      return $.extend(paths[path], node);
    },
    collapse: function(paths) {
      var node, parent, path;

      for (path in paths) {
        node = paths[path];
        parent = path.match(/(.*)\//);
        if (!(parent && (parent = parent[1]))) {
          continue;
        }
        paths[parent].children.push(node);
      }
      return paths;
    }
  };

}).call(this);
